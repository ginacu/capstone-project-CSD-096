# -*- coding: utf-8 -*-
"""Capstone_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/ginacu/capstone-project-CSD-096/blob/main/Capstone_Project.ipynb

Aplikasi Rekomendasi Skincare Berdasarkan Permasalahan Wajah
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 

# Import the Dataset 

skincare = pd.read_csv("skincare.csv")

import streamlit as st
from sklearn.manifold import TSNE 
from scipy.spatial.distance import cdist

# Choose a product category
category = st.selectbox(label='Select a product category', options= skincare['tipe_produk'].unique() )

st.write(type(category))
category_subset = skincare[skincare['tipe_produk'] == category]
# Choose a skintype
skin_type = st.selectbox(label='Select your skin type', options= ['Combination', 'Dry', 'Normal', 'Oily', 'Sensitive'] )
st.write(type(skin_type))
category_st_subset = category_subset[category_subset[skin_type] == 1]
category_st_subset
# Choose notable_effects
options_a = category_st_subset['notable_effects'].unique().tolist()
selected_options = st.multiselect('Which notable_effects do you want?',options_a)

filtered_df = category_st_subset[category_st_subset["notable_effects"].isin(selected_options)]

st.dataframe(filtered_df)

options_b = filtered_df['product_name'].unique().tolist()
product = st.selectbox(label='Select the product', options = sorted(options_b))
product

## Helper functions
# Define the one-hot encoding function
def encoding(tokens):
    x = np.zeros(N)
    for notable_effect in tokens:
        # Get the index for each ingredient
        i = notable_effect_dict[notable_effect]
        # Put 1 at the corresponding indices
        x[i] = 1
    return x

def closest_point(point, points):
    """ Find closest point from a list of points. """
    return points[cdist([point], points).argmin()]


if category is not None:
    filtered_df = skincare[skincare['tipe_produk'] == category]

if product is not None:
    #skincare_type = category_subset[category_subset[str(skin_type)] == 1]

    # Reset index
    filtered_df = filtered_df.reset_index(drop=True)

    # Display data frame
    #st.dataframe(category_subset)

    # Initialize dictionary, list, and initial index
    notable_effect_dict = {}
    corpus = []
    i = 0

    # For loop for tokenization
    for i in range(len(filtered_df)):    
        notable_effects = filtered_df['notable_effects'][i]
        notable_effects_lower = notable_effects.lower()
        tokens = notable_effects_lower.split(', ')
        corpus.append(tokens)
        for notable_effect in tokens:
            if notable_effect not in notable_effect_dict:
                notable_effect_dict[notable_effect] = i
                i += 1

                
    # Get the number of items and tokens 
    M = len(filtered_df)
    N = len(notable_effect_dict)

    # Initialize a matrix of zeros
    A = np.zeros((M,N))

    # Make a document-term matrix
    i = 0
    for tokens in corpus:
        A[i, :] = encoding(tokens)
        i +=1

model_run = st.button('Find similar products!')


if model_run:

    st.write('Based on the ingredients of the product you selected')
    st.write('here are the top 10 products that are the most similar :sparkles:')
    
    # Run the model
    model = TSNE(n_components = 2, learning_rate = 150, random_state = 42)
    tsne_features = model.fit_transform(A)

    # Make X, Y columns 
    filtered_df['X'] = tsne_features[:, 0]
    filtered_df['Y'] = tsne_features[:, 1]

    target = filtered_df[filtered_df['product_name'] == product]

    target_x = target['X'].values[0]
    target_y = target['Y'].values[0]

    df1 = pd.DataFrame()
    df1['point'] = [(x, y) for x,y in zip(filtered_df['X'], filtered_df['Y'])]

    filtered_df['distance'] = [cdist(np.array([[target_x,target_y]]), np.array([product]), metric='euclidean') for product in df1['point']]

    # arrange by descending order
    top_matches = filtered_df.sort_values(by=['distance'])

    # Compute ingredients in common
    target_notable_effects = target.notable_effects.values
    c1_list = target_notable_effects[0].split(",")
    c1_list = [x.strip(' ') for x in c1_list]
    c1_set = set(c1_list)

    top_matches['notable_effects in common'] = [c1_set.intersection( set([x.strip(' ')for x in product.split(",")]) ) for product in top_matches['notable_effects']]

    # Select relevant columns
    top_matches = top_matches[['product_name', 'price', 'description', 'notable_effects']]
    top_matches = top_matches.reset_index(drop=True)
    top_matches = top_matches.drop(top_matches.index[0])

    st.dataframe(top_matches.head(5))

